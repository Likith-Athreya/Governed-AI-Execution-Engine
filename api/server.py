from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import sqlite3
import json
import os

from core.sandbox.sandbox_manager import SandboxManager
from execution.execution_kernel import ExecutionKernel
from agents.nl_interface_agent import NaturalLanguageAgent
from core.audit_logger import log_audit
from core.audit_logger import init_db
from core.audit_logger import DB_PATH
from agents.policy_interpreter_agent import PolicyInterpreterAgent

db_path = DB_PATH

# Path to persist active policy
ACTIVE_POLICY_FILE = os.path.join(os.path.dirname(__file__), "..", "data", "policies", "active_policy.json")

def load_persisted_policy():
    """Load active policy from file if it exists."""
    if os.path.exists(ACTIVE_POLICY_FILE):
        try:
            with open(ACTIVE_POLICY_FILE, "r") as f:
                return json.load(f)
        except Exception:
            pass
    return None

def save_policy_to_file(policy: dict):
    """Persist active policy to file."""
    os.makedirs(os.path.dirname(ACTIVE_POLICY_FILE), exist_ok=True)
    with open(ACTIVE_POLICY_FILE, "w") as f:
        json.dump(policy, f, indent=2)

init_db()

app = FastAPI(title="Governed AI Execution Engine")

nl_agent = NaturalLanguageAgent()

SCHEMA = {
    "accounts": {
        "id": "INTEGER",
        "account_name": "TEXT",
        "account_type": "TEXT",
        "currency": "TEXT",
        "balance": "REAL",
        "risk_level": "TEXT",
        "created_at": "TEXT"
    },

    "vendors": {
        "id": "INTEGER",
        "vendor_name": "TEXT",
        "country": "TEXT",
        "is_blocked": "INTEGER",
        "risk_score": "INTEGER",
        "created_at": "TEXT"
    },

    "transactions": {
        "id": "INTEGER",
        "account_id": "INTEGER",
        "vendor_id": "INTEGER",
        "amount": "REAL",
        "currency": "TEXT",
        "transaction_type": "TEXT",
        "category": "TEXT",
        "transaction_date": "TEXT",
        "approved_by": "TEXT"
    },

    "budgets": {
        "id": "INTEGER",
        "department": "TEXT",
        "category": "TEXT",
        "monthly_limit": "REAL",
        "fiscal_year": "INTEGER"
    }
}

DEFAULT_POLICY = {
    "max_rows": 100
}

# Load persisted policy or use default
ACTIVE_POLICY = load_persisted_policy() or DEFAULT_POLICY
kernel = ExecutionKernel(ACTIVE_POLICY)

class NLRequest(BaseModel):
    user_input: str

class SimulateRequest(BaseModel):
    sql: str

class ExecuteRequest(BaseModel):
    sql: str
    simulation: dict
    user_input: str

class PolicyNLRequest(BaseModel):
    policy_text: str

from pydantic import BaseModel

class WhatIfRequest(BaseModel):
    policy: dict
    sql: str

def build_schema_hint(schema: dict) -> str:
    """Build a schema hint string from the SCHEMA dict for the LLM."""
    hints = []
    for table, columns in schema.items():
        col_list = ", ".join(columns.keys())
        hints.append(f"{table}({col_list})")
    return ", ".join(hints)

@app.post("/nl_to_sql")
def nl_to_sql(req: NLRequest):
    schema_hint = build_schema_hint(SCHEMA)

    plan = nl_agent.interpret(
        user_input=req.user_input,
        schema_hint=schema_hint
    )

    sql = plan.get("sql")
    if not sql:
        return {
            "status": "error",
            "reason": "No SQL generated by LLM",
            "plan": plan
        }

    return {
        "status": "ok",
        "plan": plan
    }

@app.post("/nl_simulate")
def nl_simulate(req: NLRequest):
    schema_hint = build_schema_hint(SCHEMA)

    plan = nl_agent.interpret(
        user_input=req.user_input,
        schema_hint=schema_hint
    )

    sql = plan.get("sql")
    if not sql:
        return {
            "status": "error",
            "reason": "No SQL generated by LLM",
            "plan": plan
        }

    sandbox = SandboxManager(SCHEMA)
    simulation = sandbox.simulate_query(sql)
    sandbox.teardown()

    # Mark blocked columns in the classification
    blocked_cols = set(ACTIVE_POLICY.get("blocked_columns", []))
    for col in simulation.get("columns_accessed", []):
        if col in blocked_cols:
            simulation["column_classification"][col] = "BLOCKED"

    return {
        "status": "ok",
        "plan": plan,
        "simulation": simulation
    }

@app.post("/simulate")
def simulate(req: SimulateRequest):
    sandbox = SandboxManager(SCHEMA)
    simulation = sandbox.simulate_query(req.sql)
    sandbox.teardown()

    # Mark blocked columns in the classification
    blocked_cols = set(ACTIVE_POLICY.get("blocked_columns", []))
    for col in simulation.get("columns_accessed", []):
        if col in blocked_cols:
            simulation["column_classification"][col] = "BLOCKED"

    return {
        "simulation": simulation
    }

@app.post("/execute")
def execute(req: ExecuteRequest):
    try:
        result = kernel.run_sql(req.sql, req.simulation)
        
        status = result.get("status", "UNKNOWN")
        decision = "DENIED" if status == "DENIED" else "ALLOWED"
        reason = result.get("reason", "")
        
        if "governance" in result:
            governance = result["governance"]
            if "decision" in governance:
                gov_decision = governance["decision"].get("decision", "")
                if gov_decision == "DENY":
                    decision = "DENIED"
                elif gov_decision:
                    decision = gov_decision
                reason = governance["decision"].get("explanation", reason)
        elif status == "DENIED" and "reason" in result:
            reason = result["reason"]
        
        log_audit(
            user_input=req.user_input,
            sql=req.sql,
            decision=decision,
            reason=reason,
            simulation=req.simulation
        )
        
        return result
    except Exception as e:
        raise HTTPException(
            status_code= 500, 
            details = str(e)
        )

@app.get("/audit_logs")
def get_audit_logs(limit: int = 50):
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()

        cursor.execute("""
            SELECT timestamp, user_input, sql, decision, reason, simulation
            FROM audit_logs
            ORDER BY id DESC
            LIMIT ?
        """, (limit,))

        rows = cursor.fetchall()
        conn.close()

        logs = []
        for row in rows:
            try:
                simulation_data = row[5] if row[5] else "{}"
                try:
                    simulation = json.loads(simulation_data)
                except (json.JSONDecodeError, TypeError):
                    simulation = {}
                
                logs.append({
                    "timestamp": row[0] or "",
                    "user_input": row[1] or "",
                    "sql": row[2] or "",
                    "decision": row[3] or "",
                    "reason": row[4] or "",
                    "simulation": simulation
                })
            except Exception as e:
                continue

        return logs
    except Exception as e:
        return []

@app.post("/policy/interpreter")
def interpret_policy(req: PolicyNLRequest):
    policy = PolicyInterpreterAgent().interpret(req.policy_text)
    return{
        "status": "ok",
        "policy": policy
    }

@app.post("/policy/activate")
def activate_policy(policy: dict):
    global ACTIVE_POLICY
    ACTIVE_POLICY = policy
    # Also update the existing kernel instance so new executions use this policy
    kernel.policy = ACTIVE_POLICY
    # Persist to file so it survives restarts
    save_policy_to_file(ACTIVE_POLICY)
    return {"status": "activated", "policy": ACTIVE_POLICY}

@app.post("/policy/reset")
def reset_policy():
    """Reset to default policy and remove persisted policy file."""
    global ACTIVE_POLICY
    ACTIVE_POLICY = DEFAULT_POLICY
    kernel.policy = ACTIVE_POLICY
    # Remove persisted file
    if os.path.exists(ACTIVE_POLICY_FILE):
        os.remove(ACTIVE_POLICY_FILE)
    return {"status": "reset", "policy": ACTIVE_POLICY}

@app.get("/policy/current")
def get_current_policy():
    """Get the currently active policy."""
    return {"policy": ACTIVE_POLICY}

@app.post("/policy/what_if")
def what_if(req: WhatIfRequest):
    sandbox = SandboxManager(SCHEMA)
    simulation = sandbox.simulate_query(req.sql)
    sandbox.teardown()

    temp_kernel = ExecutionKernel(req.policy)
    decision =temp_kernel.run_sql(req.sql, simulation)

    llm_explanation = PolicyInterpreterAgent().explain_effect(
        policy = req.policy,
        simulation = simulation,
        decision = decision
    )       

    return{
        "simulation": simulation,
        "decision_under_policy": decision["status"],
        "lm_explanation": llm_explanation,
    }

@app.get("/")
def root():
    return {
        "status": "running",
        "service": "Governed AI Execution Engine"
    }
