from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import sqlite3
import json
import os

from core.sandbox.sandbox_manager import SandboxManager
from execution.execution_kernel import ExecutionKernel
from agents.nl_interface_agent import NaturalLanguageAgent
from core.audit_logger import log_audit
from core.audit_logger import init_db
from core.audit_logger import DB_PATH

db_path = DB_PATH


init_db()

app = FastAPI(title="Governed AI Execution Engine")

nl_agent = NaturalLanguageAgent()

SCHEMA = {
    "customers": {
        "id": "INTEGER",
        "name": "TEXT",
        "email": "TEXT",
        "ssn": "TEXT",
        "salary": "INTEGER"
    }
}

POLICY = {
    "max_rows": 100
}

kernel = ExecutionKernel(POLICY)

class NLRequest(BaseModel):
    user_input: str

class SimulateRequest(BaseModel):
    sql: str

class ExecuteRequest(BaseModel):
    sql: str
    simulation: dict

@app.post("/nl_to_sql")
def nl_to_sql(req: NLRequest):
    schema_hint = "customers(id, name, email, ssn, salary)"

    plan = nl_agent.interpret(
        user_input=req.user_input,
        schema_hint=schema_hint
    )

    sql = plan.get("sql")
    if not sql:
        return {
            "status": "error",
            "reason": "No SQL generated by LLM",
            "plan": plan
        }

    return {
        "status": "ok",
        "plan": plan
    }

@app.post("/nl_simulate")
def nl_simulate(req: NLRequest):
    schema_hint = "customers(id, name, email, ssn, salary)"

    plan = nl_agent.interpret(
        user_input=req.user_input,
        schema_hint=schema_hint
    )

    sql = plan.get("sql")
    if not sql:
        return {
            "status": "error",
            "reason": "No SQL generated by LLM",
            "plan": plan
        }

    sandbox = SandboxManager(SCHEMA)
    simulation = sandbox.simulate_query(sql)
    sandbox.teardown()

    return {
        "status": "ok",
        "plan": plan,
        "simulation": simulation
    }

@app.post("/simulate")
def simulate(req: SimulateRequest):
    sandbox = SandboxManager(SCHEMA)
    simulation = sandbox.simulate_query(req.sql)
    sandbox.teardown()

    return {
        "simulation": simulation
    }

@app.post("/execute")
def execute(req: ExecuteRequest):
    try:
        result = kernel.run_sql(req.sql, req.simulation)
        return result
    except Exception as e:
        raise HTTPException(
            status_code= 500, 
            details = str(e)
        )

@app.get("/audit_logs")
def get_audit_logs(limit: int = 50):
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    cursor.execute("""
        SELECT timestamp, user_input, sql, decision, reason, simulation
        FROM audit_logs
        ORDER BY id DESC
        LIMIT ?
    """, (limit,))

    rows = cursor.fetchall()
    conn.close()

    logs = []
    for row in rows:
        logs.append({
            "timestamp": row[0],
            "user_input": row[1],
            "sql": row[2],
            "decision": row[3],
            "reason": row[4],
            "simulation": json.loads(row[5])
        })

    return logs