from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import sqlite3
import json
import os
from core.sandbox.sandbox_manager import SandboxManager
from execution.execution_kernel import ExecutionKernel
from core.audit_logger import log_audit, init_db, DB_PATH
from agents.policy_interpreter_agent import PolicyInterpreterAgent

ACTIVE_POLICY_FILE = os.path.join(os.path.dirname(__file__), "..", "data", "policies", "active_policy.json")

def load_persisted_policy():
    if os.path.exists(ACTIVE_POLICY_FILE):
        try:
            with open(ACTIVE_POLICY_FILE, "r") as f:
                return json.load(f)
        except Exception:
            pass
    return None

def save_policy_to_file(policy: dict):
    os.makedirs(os.path.dirname(ACTIVE_POLICY_FILE), exist_ok=True)
    with open(ACTIVE_POLICY_FILE, "w") as f:
        json.dump(policy, f, indent=2)

init_db()

app = FastAPI(title="Governed AI Execution Engine")

from agents.nl_interface_agent import NaturalLanguageAgent

nl_agent = NaturalLanguageAgent()

SCHEMA = {
    "accounts": {
        "id": "INTEGER",
        "account_name": "TEXT",
        "account_type": "TEXT",
        "currency": "TEXT",
        "balance": "REAL",
        "risk_level": "TEXT",
        "created_at": "TEXT"
    },

    "vendors": {
        "id": "INTEGER",
        "vendor_name": "TEXT",
        "country": "TEXT",
        "is_blocked": "INTEGER",
        "risk_score": "INTEGER",
        "created_at": "TEXT"
    },

    "transactions": {
        "id": "INTEGER",
        "account_id": "INTEGER",
        "vendor_id": "INTEGER",
        "amount": "REAL",
        "currency": "TEXT",
        "transaction_type": "TEXT",
        "category": "TEXT",
        "transaction_date": "TEXT",
        "approved_by": "TEXT"
    },

    "budgets": {
        "id": "INTEGER",
        "department": "TEXT",
        "category": "TEXT",
        "monthly_limit": "REAL",
        "fiscal_year": "INTEGER"
    }
}

ACTIVE_POLICY = load_persisted_policy()
if ACTIVE_POLICY is None:
    raise RuntimeError("No active policy found. Please configure a policy using /policy/activate endpoint.")

kernel = ExecutionKernel(ACTIVE_POLICY)

class NLRequest(BaseModel):
    user_input: str

class SimulateRequest(BaseModel):
    sql: str

class ExecuteRequest(BaseModel):
    sql: str
    simulation: dict
    user_input: str
    human_free: bool = False

class PolicyNLRequest(BaseModel):
    policy_text: str

class WhatIfRequest(BaseModel):
    policy: dict
    sql: str

def build_schema_hint(schema: dict) -> str:
    return ", ".join(f"{table}({', '.join(columns.keys())})" for table, columns in schema.items())

def run_simulation(sql: str, user_input: str = "") -> dict:
    sandbox = SandboxManager(SCHEMA)
    simulation = sandbox.simulate_query(sql)
    sandbox.teardown()
    
    blocked_cols = set(ACTIVE_POLICY.get("blocked_columns", []))
    for col in simulation.get("columns_accessed", []):
        if col in blocked_cols:
            simulation["column_classification"][col] = "BLOCKED"
    
    pii_detected = "PII" in simulation.get("column_classification", {}).values()
    if pii_detected:
        log_audit(user_input=user_input, sql=sql, decision="DENIED", 
                 reason="PII detected - blocked at UI level", simulation=simulation)
    return simulation

def _get_nl_plan(user_input: str, human_free: bool = False):
    schema_hint = build_schema_hint(SCHEMA)
    plan = nl_agent.interpret(user_input=user_input, schema_hint=schema_hint)
    sql = plan.get("sql")
    if not sql:
        return None, {"status": "error", "reason": "No SQL generated by LLM", "plan": plan}
    return sql, plan

@app.post("/nl_to_sql")
def nl_to_sql(req: NLRequest):
    sql, plan = _get_nl_plan(req.user_input)
    if not sql:
        return plan
    return {"status": "ok", "plan": plan}

@app.post("/nl_simulate")
def nl_simulate(req: NLRequest):
    sql, plan = _get_nl_plan(req.user_input, req.human_free if hasattr(req, 'human_free') else False)
    if not sql:
        return plan
    simulation = run_simulation(sql, req.user_input)
    return {"status": "ok", "plan": plan, "simulation": simulation}

@app.post("/simulate")
def simulate(req: SimulateRequest):
    return {"simulation": run_simulation(req.sql)}

@app.post("/execute")
def execute(req: ExecuteRequest):
    try:
        result = kernel.run_sql(req.sql, req.simulation)

        status = result.get("status", "UNKNOWN")
        decision = "DENIED" if status == "DENIED" else "ALLOWED"
        reason = result.get("reason", "")

        if "governance" in result:
            governance = result["governance"]
            if "decision" in governance:
                gov_decision = governance["decision"].get("decision", "")
                if gov_decision == "DENY":
                    decision = "DENIED"
                elif gov_decision:
                    decision = gov_decision
                reason = governance["decision"].get("explanation", reason)
        elif status == "DENIED" and "reason" in result:
            reason = result["reason"]

        log_audit(
            user_input=req.user_input,
            sql=req.sql,
            decision=decision,
            reason=reason,
            simulation=req.simulation
        )

        return result
    except Exception as e:
        raise HTTPException(
            status_code= 500,
            details = str(e)
        )

@app.get("/episodic_memory")
def get_episodic_memory():
    """Get the episodic memory of recent simulations"""
    return {"episodic_memory": kernel.episodic_memory}

@app.get("/audit_logs")
def get_audit_logs(limit: int = 50):
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        cursor.execute("SELECT timestamp, user_input, sql, decision, reason, simulation FROM audit_logs ORDER BY id DESC LIMIT ?", (limit,))
        logs = []
        for row in cursor.fetchall():
            try:
                simulation = json.loads(row[5] or "{}")
            except:
                simulation = {}
            logs.append({"timestamp": row[0] or "", "user_input": row[1] or "", "sql": row[2] or "",
                        "decision": row[3] or "", "reason": row[4] or "", "simulation": simulation})
        conn.close()
        return logs
    except:
        return []

@app.post("/policy/interpreter")
def interpret_policy(req: PolicyNLRequest):
    try:
        policy = PolicyInterpreterAgent().interpret(req.policy_text)
        return {"status": "ok", "policy": policy}
    except Exception as e:
        return {"status": "error", "error": str(e)}

@app.post("/policy/activate")
def activate_policy(policy: dict):
    global ACTIVE_POLICY
    ACTIVE_POLICY = policy
    kernel.policy = ACTIVE_POLICY
    save_policy_to_file(ACTIVE_POLICY)
    return {"status": "activated", "policy": ACTIVE_POLICY}

@app.post("/policy/reset")
def reset_policy():
    if os.path.exists(ACTIVE_POLICY_FILE):
        os.remove(ACTIVE_POLICY_FILE)
        return {"status": "reset", "message": "Policy file removed. Server restart required with new policy."}
    else:
        return {"status": "error", "message": "No policy file found to reset."}

@app.get("/policy/current")
def get_current_policy():
    return {"policy": ACTIVE_POLICY}

@app.post("/policy/what_if")
def what_if(req: WhatIfRequest):
    simulation = run_simulation(req.sql)
    temp_kernel = ExecutionKernel(req.policy)
    decision = temp_kernel.run_sql(req.sql, simulation)
    llm_explanation = PolicyInterpreterAgent().explain_effect(policy=req.policy, simulation=simulation, decision=decision)
    return {"simulation": simulation, "decision_under_policy": decision["status"], "lm_explanation": llm_explanation}

@app.get("/")
def root():
    return {"status": "running", "service": "Governed AI Execution Engine"}